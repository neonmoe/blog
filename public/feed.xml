<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Neon Blog</title>
  <subtitle>Writing about programs and programming.</subtitle>
  <link href="https://blog.neon.moe/feed.xml" rel="self" />
  <link href="https://blog.neon.moe/" />
  <id>tag:blog.neon.moe,2019-07-06:/feed</id>
  <updated>2019-07-06T01:23:38+03:00</updated>

  <entry>
	<title>My experience learning make</title>
	<link href="https://blog.neon.moe/2019/07/06/make.html" />
    <id>tag:blog.neon.moe,2019-07-06:/2019/07/06/make</id>
	<published>2019-07-06T01:23:38+03:00</published>
	<updated>2019-07-06T01:23:38+03:00</updated>
	<author>
	  <name>Jens Pitk√§nen</name>
	  <email>jens@neon.moe</email>
	</author>
	<summary>
      A journal of my journey from a casual cargo fan to a make
      evangelist. Well, not really, but it's about make and personal
      development.
    </summary>
	<content type="xhtml">
	  <div xmlns="http://www.w3.org/1999/xhtml">
        <h2>My experience learning make</h2>
        <p>When I have been looking for a new language to learn, or gauging the
        usefulness of a language, I tend to appreciate build systems as part
        of the language. I think an important property of a tool is its
        simplicity of use, and for a long time I avoided C because it did not
        have a <code>mvn</code>, <code>cargo</code>, or <code>npm</code>. I thought the lack of an in-built
        build tool made C unnecessarily complicated to get started with. After
        reading bits and pieces of the K&amp;R, making an almost whole game in C,
        and still not having touched makefiles, I have come to the conclusion
        that I was wrong. I have been happily writing C and building it with
        shell-scripts that build the program for each specific system. For
        example, I have a batch script for Windows that builds the program
        with <code>cl.exe</code>, providing the correct flags, one for Linux, and so on.</p>
        <p>The reason I wrote the shell scripts instead of makefiles is because I
        already knew how shell scripts work, and learning to use <code>cc</code> and
        <code>cl.exe</code> was quite similar to learning to use the aforementioned build
        tools. If the compilers did not do something I needed from a build
        tool, I would just write that part in the script myself. In addition
        to this, I have heard a lot about makefiles not being super portable,
        and the existence of <code>qmake</code> and <code>cmake</code> seem to prove that idea. And
        in my own experience, when I have had to call <code>make</code> manually, it has
        stumbled on my system being misconfigured somehow, which makes it seem
        prone to breakage.</p>
        <p>That said, I definitely feel like I should learn how to write a
        <code>Makefile</code>, if for no other reason than to make my negative opinion of
        them more valid. Or invalid, as the case may be ;)</p>
        <h3>Learning make</h3>
        <p>A few days ago, I got a copy of The Unix Programming Environment by
        Brian W. Kernighan and Rob Pike from the library. Why? The main reason
        was because I wanted to explore the Unix philosophy a bit further than
        what I had learned from hearing it repeatedly in tech articles and
        social media (not much). The other reason was because I imagined it
        would have a bit on <code>make</code>.</p>
        <p>It does, sort-of. The eighth chapter is about writing a big program,
        and has three digressions on <code>make</code>. Based on that, I got the
        following impression of it: makefiles define dependencies between
        generated and manually edited files, and how those dependencies
        manifest (that is, how you get from the manually written files to the
        generated ones). The connection to C becomes obvious once you think
        about C programming in those terms: first you manually edit the C
        source code, then you generate object files out of that, and then you
        generate a final executable from those.</p>
        <p>In this light, <code>make</code> seems like an obvious fit for C, but very
        general as well. I did not realize what the specific role of <code>make</code>
        was before, probably because other programming languages have built
        similar functionality into their build tools, but after this
        realization, it is obvious.</p>
        <p>On one hand, I appreciate how <code>cc</code> and <code>make</code> split the job of making
        lots of source code into an executable (something something Unix
        philosophy), but on the other hand, I can not help but feel like it is
        pointlessly complicated for the end-user. Almost every program follows
        a similar build-pipeline, or could at least be refactored to fit, so
        why not combine the functionalities to a singular build tool? Why do I
        need to learn yet another syntax just to build my C? I imagine that is
        what a lot of people thought, since there are at least a few trillion
        different tools to build a C program. I think.</p>
        <h3>Conclusion</h3>
        <p><code>Make(1)</code> is neat. I wrote a <code>Makefile</code> for this blog to test it out,
        and I enjoyed the experience after ironing out a few
        misunderstandings. It is a shame that <code>make</code> is the most universal
        tool to build C programs, I would much prefer a more <code>cargo</code>/<code>go build</code>-like experience, but it is not that bad either. If you are in a
        similar situation to mine at the beginning of this post, just go ahead
        and use <code>make</code>. It is not evil. At the very least, it can not be as
        bad as picking one of the million other C build tools, because you do
        not get anywhere by making <a href="https://xkcd.com/927/" title="Yeah, it is that one xkcd everyone always posts.">yet another standard</a>. And make sure
        to be <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html">POSIX-compatible</a>, just to be a good citizen :)</p>
        <p>As a final note, The Unix Programming Environment has been a pretty
        fun read, if a bit obsolete. At least the C is, did you know functions
        looked like this in the 1970s?</p>
        <pre><code class="language-c">main(argc, argv)
        char *argv[];
        {
        // ...
        }
        </code></pre>
        <h3>Unimportant meta footnote you can skip</h3>
        <p>This is my first techblog, and I hope it was bearable to read. I think
        my english is a bit clumsy in long-form, so if you have got any
        writing tips, or just comments on this blog overall, be sure to shoot
        them at <a href="https://moe.neon.moe/@neon">@neon@moe.neon.moe</a> (or where I might have moved to) on
        the Fediverse, or via email to <a href="mailto:jens@neon.moe">jens@neon.moe</a>.</p>
	  </div>
	</content>
  </entry>

</feed>
